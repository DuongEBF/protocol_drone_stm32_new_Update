#include "can.h"
FDCAN_HandleTypeDef* fdcan_src;
uint8_t canard_memory_pool[1024];
CanardInstance canard;
uint16_t debug;
#define CLEAR_MSB_8BIT 0x00FF
typedef enum
{
	STATE_FIND = 0,
	STATE_CONNECTED,
	STATE_TIMEOUT,
}can_link_state_t;
can_link_state_t link_state = STATE_FIND;
uint8_t tid_cryp = 0;
uint8_t tid_batt = 0;
uint16_t v;
int16_t i;
uint8_t soc;
static uint32_t last_heartbeat_tick = 0;
struct hyp_msg_HeartBeat_Hyp node;
uint16_t count = 0;
//---------------decode--------------------//
void HAL_FDCAN_RxFifo0Callback(FDCAN_HandleTypeDef *hfdcan, uint32_t filterIndex)
{
	FDCAN_RxHeaderTypeDef rxHeader;
	uint8_t rxData[8];
	if (HAL_FDCAN_GetRxMessage(hfdcan, FDCAN_RX_FIFO0, &rxHeader, rxData) != HAL_OK)
			return;
	CanardCANFrame frame;
	frame.id = rxHeader.Identifier;
	if (rxHeader.IdType == FDCAN_EXTENDED_ID)
			frame.id |= (1UL << 31); // set extended bit
	frame.data_len = rxHeader.DataLength;
	if (frame.data_len > 8) frame.data_len = 8;

	memcpy(frame.data, rxData, frame.data_len);
	frame.iface_id = 0;

	canardHandleRxFrame(&canard, &frame, HAL_GetTick() * 1000ULL);
}


static void recv_encode_packpin_ack(CanardInstance* ins, CanardRxTransfer* transfer)
{
	struct hyp_aes_Encryption_Hyp resq;
	resq.name.len = strlen("hyp_motion_ack__");
	memcpy(resq.name.data, "hyp_motion_ack__", resq.name.len);
	resq.node_id = 15;
	uint8_t buffer[HYP_AES_ENCRYPTION_HYP_MAX_SIZE];
	uint32_t len = hyp_aes_Encryption_Hyp_encode(&resq, buffer
#if CANARD_ENABLE_TAO_OPTION
        , true
#endif
    );
	canardRequestOrRespond(
							ins,
							resq.node_id,
							HYP_AES_ENCRYPTION_HYP_SIGNATURE,
							HYP_AES_ENCRYPTION_HYP_ID,
							&tid_cryp,
							CANARD_TRANSFER_PRIORITY_LOW,
							CanardResponse,
							buffer,
							len);
}
static void recv_decode_packpin_cryp(CanardInstance* ins, CanardRxTransfer* transfer)
{
	struct hyp_aes_Encryption_Hyp resp;
	hyp_aes_Encryption_Hyp_decode(transfer, &resp);
	char buff_resp[50] = {0};
	memcpy(buff_resp, resp.name.data, resp.name.len);
	if(strcmp(buff_resp, "connect") == 0)
	{
		link_state = STATE_CONNECTED;

		recv_encode_packpin_ack(ins, transfer);
	}
}

static void recv_decode_packpin_batt(CanardInstance* ins, CanardRxTransfer* transfer)
{
	struct hyp_msg_BatteryStatus_Hyp resp_batt;
	hyp_msg_BatteryStatus_Hyp_decode(transfer, &resp_batt);
	char buff_resp[50] = {0};
	i = resp_batt.current;
	v = resp_batt.voltage;
	soc = resp_batt.state_of_charge_percent;
	memcpy(buff_resp, resp_batt.name.data, resp_batt.name.len);

}
bool should_accept(const CanardInstance* ins, uint64_t* out_sig, uint16_t data_type_id,
                   CanardTransferType transfer_type, uint8_t source_node_id)
{
	if (transfer_type == CanardTransferTypeRequest)
	{
		debug = data_type_id;
		switch (data_type_id)
		{
			case HYP_AES_ENCRYPTION_HYP_ID:
			{
				*out_sig = HYP_AES_ENCRYPTION_HYP_SIGNATURE;
				return true;
			}

		}
	}
	if(transfer_type == CanardTransferTypeBroadcast)
	{
		switch(data_type_id)
		{
			case HYP_MSG_HEARTBEAT_HYP_ID:
			{
				*out_sig = HYP_MSG_HEARTBEAT_HYP_SIGNATURE;
				return true;
			}
			case HYP_MSG_BATTERYSTATUS_HYP_ID:
			{
				*out_sig = HYP_MSG_BATTERYSTATUS_HYP_SIGNATURE;
				return true;
			}
		}
	}
	return false;
}



void on_reception(CanardInstance* ins, CanardRxTransfer* transfer)
{

	if (transfer->transfer_type == CanardTransferTypeRequest)
	{
		switch (transfer->data_type_id)
		{
			case HYP_AES_ENCRYPTION_HYP_ID:
			{
				recv_decode_packpin_cryp(ins, transfer);
				break;
			}
		}
	}
	if (transfer->transfer_type == CanardTransferTypeBroadcast)
	{

		switch (transfer->data_type_id)
		{
			case HYP_MSG_HEARTBEAT_HYP_ID:
			{
				hyp_msg_HeartBeat_Hyp_decode(transfer, &node);
				break;
			}
			case HYP_MSG_BATTERYSTATUS_HYP_ID:
			{
				recv_decode_packpin_batt(ins, transfer);
				break;
			}
		}
	}
}
static void config_fdcan_filter_all(void)
{
    FDCAN_FilterTypeDef sFilterConfig;

    sFilterConfig.IdType = FDCAN_STANDARD_ID;
    sFilterConfig.FilterIndex = 0;
    sFilterConfig.FilterType = FDCAN_FILTER_MASK;
    sFilterConfig.FilterConfig = FDCAN_FILTER_TO_RXFIFO0;
    sFilterConfig.FilterID1 = 0x000;
    sFilterConfig.FilterID2 = 0x000;
    if (HAL_FDCAN_ConfigFilter(fdcan_src, &sFilterConfig) != HAL_OK)
    {
        Error_Handler();
    }

    sFilterConfig.IdType = FDCAN_EXTENDED_ID;
    sFilterConfig.FilterIndex = 1;
    sFilterConfig.FilterType = FDCAN_FILTER_MASK;
    sFilterConfig.FilterConfig = FDCAN_FILTER_TO_RXFIFO0;
    sFilterConfig.FilterID1 = 0x00000000;
    sFilterConfig.FilterID2 = 0x00000000;
    if (HAL_FDCAN_ConfigFilter(fdcan_src, &sFilterConfig) != HAL_OK)
    {
        Error_Handler();
    }
}
//---------------decode--------------------//



//--------------------------encode------------------------//

static void send_nodestatus(CanardInstance* ins)
{
	uint8_t buffer[HYP_MSG_HEARTBEAT_HYP_MAX_SIZE];
	struct hyp_msg_HeartBeat_Hyp node_status;
	node_status.health = HYP_MSG_HEARTBEAT_HYP_HEALTH_OK;
	node_status.mode = HYP_MSG_HEARTBEAT_HYP_MODE_OPERATIONAL;
	node_status.uptime_sec = HAL_GetTick()/1000;
	node_status.sub_mode = 2;
	node_status.vendor_specific_status_code = 3333;
	uint32_t len = hyp_msg_HeartBeat_Hyp_encode(&node_status, buffer);
	static uint8_t transfer_id;
    canardBroadcast(ins,
    				HYP_MSG_HEARTBEAT_HYP_SIGNATURE,
					HYP_MSG_HEARTBEAT_HYP_ID,
                    &transfer_id,
					CANARD_TRANSFER_PRIORITY_LOW,
                    buffer,
                    len);
}
static void FDCan_tx_frame(void)
{
    const CanardCANFrame* txf;
    while ((txf = canardPeekTxQueue(&canard)) != NULL)
    {
    	FDCAN_TxHeaderTypeDef txHeader;
        if ((fdcan_src->Instance->TXFQS & FDCAN_TXFQS_TFQF) == 0) // TX FIFO not full
        {
            txHeader.Identifier = txf->id & 0x1FFFFFFF;
            txHeader.IdType = FDCAN_EXTENDED_ID;
            txHeader.TxFrameType = FDCAN_DATA_FRAME;
            txHeader.DataLength = txf->data_len;
            txHeader.FDFormat = FDCAN_CLASSIC_CAN;
            txHeader.BitRateSwitch = FDCAN_BRS_OFF;
            txHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;
            txHeader.MessageMarker = 0;

            if (HAL_FDCAN_AddMessageToTxFifoQ(fdcan_src, &txHeader, (uint8_t*)txf->data) == HAL_OK)
            {
                canardPopTxQueue(&canard);
            }
            else
            {
                break;
            }
        }
        else
        {
            break;
        }
    }
}
//--------------------------encode------------------------//


//-----------------------Init------------------------//
void FDCan_Init(FDCAN_HandleTypeDef* fdcan)
{
    fdcan_src = fdcan;

    // Init CAN hardware
    HAL_FDCAN_Start(fdcan_src);
    HAL_FDCAN_ActivateNotification(fdcan_src, FDCAN_IT_RX_FIFO0_NEW_MESSAGE, 0);
    config_fdcan_filter_all();

    // Init libcanard
    canardInit(&canard,
				canard_memory_pool,
				sizeof(canard_memory_pool),
				on_reception,
				should_accept,
				NULL);
    canardSetLocalNodeID(&canard, 11);
}

void FDCan_Handle(void)
{
	if(HAL_GetTick()/1000 - node.uptime_sec > 4)
	{
		link_state = STATE_TIMEOUT;
	}

	if(link_state == STATE_TIMEOUT)
	{
		link_state = STATE_FIND;
	}
	if(link_state == STATE_CONNECTED)
	{
		static uint32_t last_send_nodeStatus = 0;
		if(HAL_GetTick() - last_send_nodeStatus >= 1000)
		{

			send_nodestatus(&canard);
			count++;
			last_send_nodeStatus = HAL_GetTick();
		}
	}

	FDCan_tx_frame();
}
//-----------------------Init------------------------//
